#!/usr/bin/env node
/**
 * Build script to generate CLAUDE.md and AGENTS.md from docs/AGENTS.src.md.
 *
 * This script parses the source file and generates two output files:
 * - CLAUDE.md: includes START_CLAUDE...END_CLAUDE blocks, excludes START_AGENTS...END_AGENTS
 * - AGENTS.md: includes START_AGENTS...END_AGENTS blocks, excludes START_CLAUDE...END_CLAUDE
 *
 * Usage:
 *   node scripts/build-agent-docs.mjs
 *
 * The source file uses markers on their own lines:
 *   START_CLAUDE / END_CLAUDE - content appears only in CLAUDE.md
 *   START_AGENTS / END_AGENTS - content appears only in AGENTS.md
 *   START_IGNORE / END_IGNORE - content stripped from both (e.g., source file metadata)
 */

import { readFileSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const REPO_ROOT = join(__dirname, '..');
const SOURCE_FILE = join(REPO_ROOT, 'docs', 'AGENTS.src.md');
const CLAUDE_OUTPUT = join(REPO_ROOT, 'CLAUDE.md');
const AGENTS_OUTPUT = join(REPO_ROOT, 'AGENTS.md');

const HEADER = `<!-- AUTOGENERATED FILE, DO NOT EDIT DIRECTLY -->
<!-- To regenerate, run \`npm run agent-docs\` -->
<!-- Source content: docs/AGENTS.src.md -->

`;

const MARKER_TYPES = ['CLAUDE', 'AGENTS', 'IGNORE'];

/**
 * Validate that all markers are properly paired and not nested.
 * Nesting is forbidden because the generator uses a single skip flag.
 * @param {string[]} sourceLines - Lines from the source file
 * @throws {Error} If markers are unbalanced or nested
 */
function validateMarkers(sourceLines) {
    let currentBlock = null; // { type, lineNum } or null

    for (let i = 0; i < sourceLines.length; i++) {
        const stripped = sourceLines[i].trim();
        const lineNum = i + 1;

        for (const type of MARKER_TYPES) {
            if (stripped === `START_${type}`) {
                if (currentBlock !== null) {
                    throw new Error(
                        `Nested markers not allowed: START_${type} at line ${lineNum} is inside START_${currentBlock.type} (line ${currentBlock.lineNum})`,
                    );
                }
                currentBlock = { type, lineNum };
            } else if (stripped === `END_${type}`) {
                if (currentBlock === null) {
                    throw new Error(`Unmatched END_${type} at line ${lineNum} (no matching START_${type})`);
                }
                if (currentBlock.type !== type) {
                    throw new Error(
                        `Mismatched markers: START_${currentBlock.type} at line ${currentBlock.lineNum} closed by END_${type} at line ${lineNum}`,
                    );
                }
                currentBlock = null;
            }
        }
    }

    if (currentBlock !== null) {
        throw new Error(`Unclosed marker: START_${currentBlock.type} at line ${currentBlock.lineNum}`);
    }
}

/**
 * Generate output for a specific target (CLAUDE or AGENTS).
 * @param {string[]} sourceLines - Lines from the source file
 * @param {string} target - Either "CLAUDE" or "AGENTS"
 * @returns {string} The processed content for the target
 */
function generateOutput(sourceLines, target) {
    const outputLines = [];
    let skipUntilEnd = null;
    const otherTarget = target === 'CLAUDE' ? 'AGENTS' : 'CLAUDE';

    for (const line of sourceLines) {
        const stripped = line.trim();

        // Check for IGNORE markers (stripped from both outputs)
        if (stripped === 'START_IGNORE') {
            skipUntilEnd = 'END_IGNORE';
            continue;
        }
        if (stripped === 'END_IGNORE') {
            skipUntilEnd = null;
            continue;
        }

        // Check for start markers
        if (stripped === `START_${target}`) {
            // Start including content for our target (skip the marker itself)
            continue;
        }
        if (stripped === `START_${otherTarget}`) {
            // Start skipping content for other target
            skipUntilEnd = `END_${otherTarget}`;
            continue;
        }

        // Check for end markers
        if (stripped === `END_${target}`) {
            continue;
        }
        if (stripped === `END_${otherTarget}`) {
            skipUntilEnd = null;
            continue;
        }

        // Skip lines if we're in a block for the other target or in IGNORE
        if (skipUntilEnd) {
            continue;
        }

        // Include the line
        outputLines.push(line);
    }

    return outputLines.join('\n');
}

/**
 * Clean up excessive empty lines that result from removing blocks.
 * - Reduces 3+ consecutive newlines to 2 (one blank line)
 * - Removes leading blank lines
 * @param {string} content
 * @returns {string}
 */
function cleanEmptyLines(content) {
    return content.replace(/\n{3,}/g, '\n\n').replace(/^\n+/, '');
}

function main() {
    let sourceContent;
    try {
        sourceContent = readFileSync(SOURCE_FILE, 'utf-8');
    } catch (err) {
        console.error(`Error reading source file ${SOURCE_FILE}:`, err.message);
        process.exit(1);
    }

    const sourceLines = sourceContent.split(/\r?\n/);

    // Validate markers before generating
    validateMarkers(sourceLines);

    // Generate CLAUDE.md
    let claudeContent = generateOutput(sourceLines, 'CLAUDE');
    claudeContent = cleanEmptyLines(claudeContent);
    try {
        writeFileSync(CLAUDE_OUTPUT, HEADER + claudeContent, 'utf-8');
    } catch (err) {
        console.error(`Error writing ${CLAUDE_OUTPUT}:`, err.message);
        process.exit(1);
    }
    console.log(`Generated: ${CLAUDE_OUTPUT}`);

    // Generate AGENTS.md
    let agentsContent = generateOutput(sourceLines, 'AGENTS');
    agentsContent = cleanEmptyLines(agentsContent);
    try {
        writeFileSync(AGENTS_OUTPUT, HEADER + agentsContent, 'utf-8');
    } catch (err) {
        console.error(`Error writing ${AGENTS_OUTPUT}:`, err.message);
        process.exit(1);
    }
    console.log(`Generated: ${AGENTS_OUTPUT}`);
}

main();
